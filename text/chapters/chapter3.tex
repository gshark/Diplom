\chapter{Тестирование}

\section{Структура данных для дерева разбора}
Для проверки того, что код корректно приобразуется в дерево разбора, а потом обратно в исходный код, а также
для проверки достаточного покрытия программ олимпиадного проограммирования реализованным подмножеством языка,
были взяты случайные решения из архива \texttt{PCMS2}~--- тестирующая система, используемая в Университете ИТМО
для обучения школьников и студентов, а также проведения различных соревнований вплоть до всероссийской командной
олимпиады школьников по программированию и полуфиналу чемпионата мира по программированию ACM ICPC.

На 47 из 50 выбранных программ структура отработала корректно. В остальных трех сказалась неполнота подмножества языка:
\begin{enumerate}
    \item В первой программе использовалось объявление типа через \texttt{record}.
    \item Во второй условный оператор \texttt{case}.
    \item В третьей конструкция \texttt{writeln(a:5:1)}.
\end{enumerate}
Все три причины не входят в подмножество языка, однако при добавлении их в грамматику, в дальнейшем смогут обрабатываться корретно.
Третья конструкция и вовсе не предусмотрена стандартной грамматикой языка Паскаль, реализованной разработчиками ANTLR, но вполне
может быть дописана на языке ANTLR, как отмечалось ранее, в грамматику можно дописать все, что душе угодно.

\section{Придуманные тесты}
\subsection{Различные популярные ошибки}
Для первоначальной проверки работы были взяты случайные решения из архива \texttt{PCMS2}, в которые были добавлены ошибки взятые из
опыта работы в учебной сфере автора работы:
\begin{itemize}
    \item Неправильные константы.
    \item Потерянные $\pm 1$ в индексах массивов. В том числе и многомерных.
    \item Неправильные типы переменных.
    \item Неправильные размерности массивов.
    \item Орфографические ошибки в модификаторах, например написать \texttt{vor} вместо \texttt{var}.
\end{itemize} 
Для всех этих случаев, все работало безотказно. Однако, это сомнительный показатель, так как все-таки исправление, которое ищется
в той же самой программе. Именно поэтому перед тестами на реальных данных будет приведено последнее внутреннее тестирование. 
\subsection{Обфускация}
\textbf{Обфускация} (от англ. obfuscate~--- делать неочевидным, запутанным, сбивать с толку)~--- приведение исходного текста 
программы к виду, сохраняющему её функциональность, но затрудняющему анализ, понимание алгоритмов работы и модификацию кода. 
В промышленности данный прием применяют, наприемр, для сокрытия корпоративных тайн, в случае, когда надо открыть код.

По сути обфускация, это <<загрязнение кода>>: переименование пременных, добавление нейтральных строк, изменение форматирования
и т.д. Модифицируем предыдущий метод тестирования, применив обфускацию, которая:
\begin{itemize}
    \item переименовывает переменные в строки из десяти и больше случайных латинских букв;
    \item убирает отступы;
    \item случайно переставляет объявление функций, констант и переменных между собой;
    \item добавляет лишние переменные и константы;
    \item добавляет нейтральные строки, вида присвоения переменной, которой раньше не было какого-то значения.
\end{itemize} 

После обфускации запускаем реализованный алгоритм, затем выясняется, что он работает абсолютно также, как и  в предыдущем случае.
То есть он находит исправления в таком же коде, реализованном по-другому, игнорируя другие имена переменных и изменения общей структуры.
Данный результат был довольно предсказуем, исходя из описания алгоритма, однако, тот факт, что работа оправдывает 
возложенные ожидания, не может не радовать.
\section{Реальные данные}
Ну тут что-то появиться. Со временем. Надеюсь. Очень. Пожалуйста.
\chapterconclusion

\begin{enumerate}
    \item Проведено тестирование структуры данных.
    \item Проведено тестирование на искусственных и естественных тестах.
    \item Показаны результаты работы.
\end{enumerate}
