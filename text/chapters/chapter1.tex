%% Начало содержательной части.
\chapter{Обзор области, постановка задачи}

\section{Термины и понятия}

В данном разделе описаны основные термины и понятия, используемые в представленной работе.

\subsection{Олимпиадное программирование}

\textbf{Задача} олимпиадного программирования представляет из себя некоторое задание, которое требуется выполнить, написав
программу на одном из языков программирования. Чтобы проверить корректность выполнения задания, текст программы
отправляют на проверку в тестирующую систему.

Под \textbf{тестирующей системой} в данной работе будем подразумевать сервер, на который учащиеся отправляют свой код, 
для проверки его корректного выполнения на заранее подготовленных тестах.

\textbf{Teст} для олимпиадной задачи по программированию~--- некоторые входные данные, удовлетворяющие условию задачи.
Как правило, представляет из себя текстовый файл. Для каждой задачи обычно существует свой набор тестов. В наборе может быть,
как один, так и несколько тестов. Тесты составляются до проведения соревнования или занятия и обычно неизвестны учащемуся.

\textbf{Решением} олимпиадной задачи называют программу, которая считывает входные данные, находит ответ и выводит его.
Также нередко в условии задачи присутствуют ограничения на время выполнения и количество используемой памяти, поэтому
корректное решение должно укладываться в эти ограничения.

\textbf{Вердикт} тестирующей системы~--- ответ тестирующей системы после проверки некоторого решения. 
Может быть положительным или одним из отрицательных. 
В случае получения положительного ответа, считается, что задача решена правильно, иначе, что в решении присутствует ошибка.
Как правило, вместе с вердиктом учащийся получает комментарий с номером теста, на котором решение работает некорректно.

\subsection{Ошибки в олимпиадном программировании}

\textbf{Ошибкой} будем называть причину, по которой решение получает отрицательный вердикт на одном из тестов.

Множество ошибок можно интуитивно разделить на несколько категорий:
\begin{enumerate}
    \item \textbf{Идейные}. Данные ошибки совершаются по причине написания неправильной интерпритации условия,
        либо некорректного выбора алгоритма для решения. Простой пример~--- решение задачи динамического программирования 
        о рюкзаке, используя метод жадного программирования. 
    \item \textbf{Неэффективный выбор алгоритма}. У некоторых алгоритмов бывают разные версии и модификации,
        поэтому бывает, что, например вместо реализации алгоритма Дейкстры с кучей, учащийся пишет 
        реализацию алгоритма Дейкстры без кучи. В подобных случаях решение выдает правильный ответ, но может
        либо потреблять памяти больше, чем указанное в условии максимальное доступное количество памяти
        либо не успевает завершиться раньше указанного в условии максимального времени работы.
    \item \textbf{Неаккуратная реализация} также является частой причиной нарушения ограничений работы.
        Например, в решении используется неоптимальный способ считывания входных данных, или неподходящая
        структура данных. Сюда же можно отнести обращения к незаалоцированной памяти и подобные ошибки.
        Основная причина таких ошибок, заключается в том, что учащийся придумал правильную идею решения, 
        выбрал правильный алгоритм, но не смог его корректно реализовать.  
    \item \textbf{Нерассмотренные случаи} часто приводят к отрицательным вердиктам. Во многих задачах существуют крайние случаи,
        например, когда в массиве один элемент и в этом случае программа будет работать некорректно. Лечатся такие ошибки при помощи
        условного оператора и отдельного рассмотрения этих самых случаев.
    \item \textbf{<<Мелкие>>} ошибки можно сравнить с помарками при решении математической задачи, на подобии потери знака при переносе.
        Такие ошибки легко допустить, но сложно заметить при самопроверке. В области олимпиадного программирования к таким ошибкам
        можно причислить неправильные типы, ошибки в индексации, неправильные размеры массивов. Особым отличием таких ошибок
        является то, что для того, чтобы помочь учащемуся, достаточно просто указать область кода, где она совершена, либо
        ограничится фразой по типу: <<У Вас ошибка в ограничениях в массиве>>, либо <<Нужно использовать 
        шестидесятичетырехбитный тип данных, вместо тридцатидвухбитного>>.   
\end{enumerate}


\subsection{Теория графов}

\textbf{Граф}~--- абстрактный математический объект, который характеризует 
пара $G = (V, E)$, где $V$~--- множество вершин, а $E \subset \{(v, u): v, u \in V\}$~--- множество ребер. 

\textbf{Связный граф}~--- граф, в котором между любой парой вершин существует хотя бы один путь.

\textbf{Цикл}~--- последовательность вершин вида $v_1, v_2 \dots v_k$, где $v_i \in V$, 
$(v_i, v_{i+1}) \in E$ и $v_1 = v_k$.

\textbf{Ациклический граф}~--- граф, который не содержит в себе циклов.

\textbf{Дерево}~--- связный ациклический граф.

В данной работе рассматриваются \textbf{подвешенные} деревья. Это деревья, у которых для каждых двух смежных по ребру
вершин выполняется отношение предок-потомок(по-другому родитель-ребенок).

Вершина, у которой нет потомков называется \textbf{листом}, в свою очередь вершина, у которой нет предков,
называется \textbf{корнем}. Очевидно, что у любого дерева ровно один корень, при этом листьев может быть сколько угодно много.

Рассмотрим некоторое дерево $T = (V, E)$. \textbf{Поддеревом} данного дерева будет дерево $T' = (V', E')$, такое что
$V' \subset V$ и $E' = \{(v, u) \in E : v, u \in V'\}$, при этом если $v \in V'$, то для любой
вершины $w$~--- потомок $v$ в дереве $T$, выполняется $w \in V'$

\textbf{Разностью} дерева $T = (V, E)$ и его поддерева $T' = (V', E')$ будем называть дерево $T'' = (V'', E'')$,
такое что $V'' = V \setminus V'$ и $E'' = \{(v, u) \in E : v, u \notin V'\}$. Интуитивно можно представить, что от дерева
$T$ <<отрезали>> его поддерево $T'$. Обозночать будем $T'' = T \setminus T'$.


\textbf{Поиск в глубину}~--- один из наиболее популярных алгоритмов обхода графа, используемый для изучения строения. 

\subsection{Синтаксический анализ}

\textbf{Абстрактное синтаксическое дерево} (дерево разбора)~--- структура данных, представляющая из себя ориентированное дерево, 
в котором каждая вершина сопоставляется с оператором языка программирования, а листья с соответствующими операндами. 

\textbf{Лексический анализ}~--- процесс аналитического разбора 
входного текста на известные группы, с последующем получением на выходе 
идентифицированных последовательностей, называемых <<токенами>>. 
Лексический анализ используется в компиляторах и интерпретаторах исходного кода языков программирования, 
и в различных парсерах слов естественных языков.

\textbf{Лексическим анализатором} (жарг. лексер от англ. $lexer$) называется программа, выполняющая лексический анализ текста.

\textbf{Синтаксический анализ}(жарг. парсинг от англ. $parsing$)~--- процесс сопоставления последовательности токенов(слов)
формального языка с его формальной грамматикой. Результатом будет абстрактное синтаксическое дерево. Как правило, для получения
токенов проводится лексический анализ.

\textbf{Синтаксическим анализатором} (жарг. парсер от англ. $parser$) называется программа выполняющая синтаксический анализ.

\textbf{Контекстно-свободная грамматика}~---  способ описания формального языка, в котором нет зависимости от контекста.

\textbf{Генератор синтаксических анализаторов}~--- программа, которая получает на вход контекстно-свободную грамматику 
некоторого языка, а на выход выдает синтезированный код лексического и синтаксического анализаторов для данного языка.
Для большинства используемых в олимпиадном программировании языков программирования 
существуют стандартные уже реализованные грамматики.

\section{Постановка цели исследования}
\subsection{Предпосылки}

Рассмотрим некоторый кружок, онлайн-курс или что-то подобное по олимпиадному программированию. 
В нем обучается некоторое количество учащихся, которых, как правило, многократно больше, чем преподавателей.

Процесс обучения включает в себя практику, которая представляет из себя решение олимпиадных задач, с последующей
отправкой решений на проверку в тестирующую систему. На каждую посылку решения, тестирующая система выдает некоторый вердикт.
В том случае, если вердикт положительный задача считается решенной правильно, и учащийся с чистой совестью переходит к решению
следующих задач, иначе же, учащийся будет пытаться самостоятельно найти ошибку.

Однако, как правило, большинство учащихся из-за лени, недостатка опыта, знаний или еще каких-либо причин не могут найти ошибку
самостоятельно и обращаются к преподавателю за помощью. Чтобы помочь в поиске ошибки, преподавателю необходимо прочитать код учащегося,
иногда не один раз, и потратить некоторое время. Когда подобных учащихся много, то и преподавательского времени тратиться 
непомерно много. Несложно предположить, что продуктивность преподавания можно повысить, если избавить преподавателя от 
подобных обязанностей путем автоматизации процесса.

Таким образом имеем базу предыдущих решений задачи с вердиктами, в том числе и с отрицательными, которые храняться в 
тестирующей системе. Хотим на основе этой информации, когда приходит новый запрос от учащегося на поиск ошибки, 
находить ее автоматически, если такая или подобная ей уже допускалась ранее другим участником. 

\subsection{Выбор фокусировки исследования}
В представленой работе будем фокусироваться именно на <<мелких>>, на что есть несколько достаточно веских причин:
\begin{itemize}
    \item Ошибки, не являющееся <<мелкими>> непонятно как именно находить, и скорее всего задача по поиску таких
        является NP-полной.
    \item Также, даже если представить, что мы нашли не являющуюся <<мелкой>> ошибку автоматически, неясно как
        компьютер сможет объяснить участнику, что же у него не так. Естественно фраза <<Замените вот тот код, на вот этот>>
        с приложенным следом кодом сомнительна, как минимум потому, что с таким же успехом, можно сказать <<вот правильный
        код, используйте его>>.
    \item Как было сказано выше, в случае <<мелкой>> ошибки, компьютер будет несложно научить давать комментарии, помогающие
        найти и исправить ее. 
    \item В случае поиска <<мелкой>> ошибки лично преподавателем, нужно прочитать
        весь код, иногда несколько раз. Именно на поиски таких ошибок, обычно, тратится наибольшее количество
        преподавательского времени.
    \item <<Мелкие>> ошибки чаще всего встречаются в коде, который нужно посмотреть преподавателю на предмет ошибок, 
        так как учащемуся проще их допустить, а также гораздо сложнее найти их самостоятельно.
    \item Такие ошибки также обладают свойством повторяться, ведь чем меньше размер кода представляющего ошибку, 
        тем больше вероятность, что подобную повторит кто-либо другой.
\end{itemize}


\section{Обзор смежной области}
Существуют несколько работ в смежных областях, цели которых чем-то похожи на поставленную в этой работы.

\subsection{Software transplantation}
Работа, которая на первый взгляд должна помочь в достижении поставленной цели~--- 
это <<Automated software transplantation>>~\cite{software-transplantation}.

В данной работе авторы рассматривают возможность <<пересадки>> кода из одной программы в другую, с целью передачи 
необходимой функциональности, по аналогии с трансплантацией огранов живого организма.

Для того, чтобы сделать это берется весь необходимый код, смотряться его зависимости от окружения и других частей программы, 
все это <<вырезается>> и ставится в код назначения в указанное место.

Несмотря на то, что метод зарекомендовал себя очень хорошо, работая в подовляющем большинстве тестовых случаев, применимо к поставленной
цели его использовать невозможно. Так как он попросту будет пересаживать код из правильного решения в неправильное и сообщать
что-то наподобии <<Я, конечно, не знаю, где у Вас ошибка, но если вы допишите в точности вот этот код, 
который раньше уже сдали в систему, то и Вы сдадите>>. Польза от данной информации, как уже было отмечено ранее крайне сомнительна,
да и в принципе ставит под вопрос необходимость использования таких сложных методов, лишь для того, чтобы показать учащемуся
правильный код, что, кстати, обычно, не делают, ведь теряется смысл обучения.

\subsection{Система поиска плагиата}
Имеет место идея применения парсеров и деревьев разбора, для поиска плагиата в текстах программ~\cite{anti-plagiat}.

Сравнения на плагиат в данной работе происходит ни непосредственно текста программы, а дерева разбора. Представленный
подход хорош тем, что сравнивает структуры программ, поэтому устойчив к переименованиям и переписыванием кода
с одного языка программирования на другой.

Также одной из особенностей работы является расширяемость за счет добавления новых грамматик на вход 
генератора синтаксических анализаторов. То есть, чтобы начать проверять новый язык программирования, надо
просто предоставить его грамматику.

Однако антиплагиат умеет лишь сравнивать два кода на похожесть по запрограммированной метрике, однако
он никак не может изменять программу, что для достижения поставленной цели в работе просто необходимо.
Также крупной проблемой является то, что в данном случае ищется именно плагиат, а в случае олимпиадного программирования
имеем один алгоритм реализованный двумя разными людьми, возможно, двумя абсолютно разными подходами.

Все же, возможность сравнивать отдельные части дерева разбора для сравнения их на похожесть~--- это идея,
которая найдет отражение в решении поставленной задачи.                                                                                                       

\subsection{Выводы по обзору смежной области}
К сожалению, ни одна из рассмотренных работ не помогает в достижении поставленной цели.
%других работ, которые были бы хотя бы настолько близки к поставленной задаче попросту не существует, 
%либо они не были найдены, несмотря на активные поиски автора. 
Что подводит к необходимости разработки своей системы синтеза
исправлений.


\section{Постановка задачи для исследования}
Основой исследования будут ранее сделанные изменения в коде решения, которые программа будет пробовать применить к текущему решению,
в котором требуется исправить ошибку. В этом разделе речь пойдет про решения по одной конкретной задаче.

Рассмотрим два решения некоторого участника, который ранее получил положительный вердикт, по интересующей нас задаче.
При этом первое решение из рассматриваемых получило отрицательный вердикт, а второе либо положительный, либо отрицательный, но
на более высоком номере теста. Важно, чтобы второе решение, было позже в хронологическом порядке, интересны именно изменения, которые
привели к улучшению вердикта.

Затем рассмотрим деревья разбора для кода двух выбранных решений. Дерево разбора первого решения назовем $A$, второго~--- $B$.
\textbf{Исправлением} назовем пару $(C_1, C_2)$, где $C_1$~--- поддерево дерева $A$, $C_2$~--- поддерево дерева $B$,
при этом $A \setminus C_1 = B \setminus C_2$. Интуитивно исправление представляется следующим образом: из первого решения
удалили отрывок кода, который сопоставлялся дереву разбора $C_1$, а вместо него написали отрывок кода, сопоставляющийся $C_2$,
получив таким  образом второе решение. С точки зрения деревьев, одно поддерево было заменено на другое.

По определению исправление улучшает вердикт для решения задачи. Под \textbf{опытом} будем подразумевать известные исправления.

Пусть теперь мы получили новое решение учащегося, в котором нужно найти ошибку. Также знаем для него вердикт тестирующей системы. 
Рассмотрим все прошлые исправления $(C_1, C_2)$ по данной задаче, после чего попробуем применить его уже к новому решению. 
Для этого в дереве разбора нового решения необходимо найти поддерево <<похожее>> на $C_1$, заменить его на поддерево
<<похожее>> на $C_2$, а затем проверить подошло исправление или нет. Будем считать его подходящим, если при отправке
получившегося кода в тестирующую систему вердикт будет лучше, чем полученный ранее.

Таким образом, можно по пунктам сформулировать окончательную задачу для исследования:
\begin{itemize}
    \item Выбрать метод анализа деревьев разбора программ.
    \item Научиться находить исправление по двум разным версиям одного решения.
    \item Сформулировать критерий <<похожести>> двух поддеревьев.
    \item Научиться применять исправление.
    \item Проверить исправление на улучшение вердикта.
    \item Оценить эффективность и предложить пути улучшения.
\end{itemize}

\chapterconclusion

\begin{enumerate}
    \item Введены необходимые термины и определения.
    \item Установлено, что существующие методы работы с кодом, не применимы для решения задачи синтеза исправлений 
        в олимпиадной задаче по программированию.
    \item Сформулирована цель и задача исследования выпускной квалификационной работы.
\end{enumerate}
