%% Начало содержательной части.
\chapter{Обзор}

\section{Термины и понятия}

В данном разделе описаны основные термины и понятия, используемые в представленной работе.

\subsection{Олимпиадное программирование}

\textbf{Задача} олимпиадного программирования представляет из себя некоторое задание, которое требуется выполнить, написав
программу на одном из языков программирования. Чтобы проверить корректность выполнения задания, текст программы
отправляют на проверку в тестирующую систему.

Под \textbf{тестирующей системой} в данной работе будем подразумевать сервер, на который учащиеся отправляют свой код, 
для проверки его корректного выполнения на заранее подготовленных тестах.

\textbf{Teст} для олимпиадной задачи по программированию~--- некоторые входные данные, удовлетворяющие условию задачи.
Как правило, представляет из себя текстовый файл. Для каждой задачи обычно существует свой набор тестов. В наборе может быть,
как один, так и несколько тестов. Тесты составляются до проведения соревнования или занятия и обычно неизвестны учащемуся.

\textbf{Решением} олимпиадной задачи называют программу, которая считывает входные данные, находит ответ и выводит его.
Также нередко в условии задачи присутствуют ограничения на время выполнения и количество используемой памяти, поэтому
корректное решение должно укладываться в эти ограничения.

\textbf{Вердикт} тестирующей системы~--- ответ тестирующей системы после проверки некоторого решения. 
Может быть положительным или одним из отрицательных. 
В случае получения положительного ответа, считается, что задача решена правильно, иначе, что в решении присутствует ошибка.
Как правило, вместе с вердиктом учащийся получает комментарий с номером теста, на котором решение работает некорректно.


\subsection{Теория графов}

\textbf{Граф}~--- абстрактный математический объект, который характеризует 
пара $G = (V, E)$, где $V$~--- множество вершин, а $E \subset \{(v, u): v, u \in V\}$~--- множество ребер. 

\textbf{Связный граф}~--- граф, в котором между любой парой вершин существует хотя бы один путь.

\textbf{Цикл}~--- последовательность вершин вида $v_1, v_2 \dots v_k$, где $v_i \in V$, 
$(v_i, v_{i+1}) \in E$ и $v_1 = v_k$.

\textbf{Ациклический граф}~--- граф, который не содержит в себе циклов.

\textbf{Дерево}~--- связный ациклический граф.

\textbf{Поиск в глубину}~--- один из наиболее популярных алгоритмов обхода графа, используемый для изучения строения. 

\subsection{Синтаксический анализ}

\textbf{Абстрактное синтаксическое дерево}(дерево разбора)~--- структура данных, представляющая из себя ориентированное дерево, 
в котором каждая вершина сопоставляется с оператором языка программирования, а листья с соответствующими операндами. 

\textbf{Лексический анализ}~--- процесс аналитического разбора 
входного текста на известные группы, с последующем получением на выходе 
идентифицированных последовательностей, называемых <<токенами>>. 
Лексический анализ используется в компиляторах и интерпретаторах исходного кода языков программирования, 
и в различных парсерах слов естественных языков.

\textbf{Лексическим анализатором}(жарг. лексер от англ. $lexer$) называется программа, выполняющая лексический анализ текста.

\textbf{Синтаксический анализ}(жарг. парсинг от англ. $parsing$)~--- процесс сопоставления последовательности токенов(слов)
формального языка с его формальной грамматикой. Результатом будет абстрактное синтаксическое дерево. Как правило, для получения
токенов проводится лексический анализ.

\textbf{Синтаксическим анализатором}(жарг. парсер от англ. $parser$) называется программа выполняющая синтаксический анализ.

\textbf{Генератор синтаксических анализаторов}~--- программа, которая получает на вход контекстно-свободную грамматику 
некоторого языка, а на выход выдает синтезированный код лексического и синтаксического анализаторов для данного языка.
Для большинства используемых в олимпиадном программировании языков программирования 
существуют стандартные уже реализованные грамматики.

\subsection{Классификация ошибок}


\textbf{Ошибкой} будем называть причину, по которой решение получает отрицательный вердикт на одном из тестов.

%ошибку, которая заключается в некорректной реализации правильной идеи при написании кода
%и при этом ее размер относительно мал.


Множество ошибок можно интуитивно разделить на несколько категорий:
\begin{enumerate}
    \item \textbf{Идейные}. Данные ошибки совершаются по причине написания неправильной интерпритации условия,
        либо некорректного выбора алгоритма для решения. Простой пример~--- решение задачи динамического программирования 
        о рюкзаке, используя метод жадного программирования. 
    \item \textbf{Неэффективный выбор алгоритма}. У некоторых алгоритмов бывают разные версии и модификации,
        поэтому бывает, что, например вместо реализации алгоритма Дейкстры с кучей, учащийся пишет 
        реализацию алгоритма Дейкстры без кучи. В подобных случаях решение выдает правильный ответ, но может
        либо потреблять памяти больше, чем указанное в условии максимальное доступное количество памяти
        либо не успевает завершиться раньше указанного в условии максимального времени работы.
    \item \textbf{Неаккуратная реализация} также является частой причиной нарушения ограничений работы.
        Например, в решении используется неоптимальный способ считывания входных данных, или неподходящая
        структура данных. Сюда же можно отнести обращения к незаалоцированной памяти и подобные ошибки.
        Основная причина таких ошибок, заключается в том, что учащийся придумал правильную идею решения, 
        выбрал правильный алгоритм, но не смог его корректно реализовать.  
    \item \textbf{Нерассмотренные случаи} часто приводят к отрицательным вердиктам. Во многих задачах существуют крайние случаи,
        например, когда в массиве один элемент и в этом случае программа будет работать некорректно. Лечатся такие ошибки при помощи
        условного оператора и отдельного рассмотрения этих самых случаев.
    \item \textbf{<<Мелкие>>} ошибки можно сравнить с помарками при решении математической задачи, на подобии потери знака при переносе.
        Такие ошибки легко допустить и сложно заметить при самопроверке. В области олимпиадного программирования 


         
\end{enumerate}


\section{Code transplantation}
Тут расскажу про подход и почему он не подходит.

\section{На будущее. вторая глава вообще?}

\subsection{Ошибки}
Рассмотрим случайную программу с ошибкой и поймем, почему нужно рассматривать именно <<мелкие>> ошибки:
\begin{itemize}
    \item Ошибки, не являющееся <<мелкими>>, легко найти, потому что обычно они бросаются в глаза, либо потому что
        они идейные, либо потому что занимают много места. В то же время, чтобы найти <<мелкую>> ошибку, нужно прочитать
        весь код, иногда несколько раз. Именно на поиски таких ошибок, обычно, тратится наибольшее количество
        преподавательского времени.
    \item <<Мелкие>> ошибки чаще всего встречаются в коде, который нужно посмотреть преподавателю на предмет ошибок, 
        так как учащемуся проще их допустить, а также гораздо сложнее найти их самостоятельно.
    \item Такие ошибки также обладают свойством повторяться, ведь чем меньше ошибка, тем больше вероятность, что подобную
        повторит кто-либо другой.
\end{itemize}
\chapterconclusion

TBD