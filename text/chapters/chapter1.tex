%% Начало содержательной части.
\chapter{Обзор}

\section{Термины и понятия}

В данном разделе описаны основные термины и понятия, используемые в представленной работе.

\subsection{Олимпиадное программирование}

\textbf{Задача} олимпиадного программирования представляет из себя некоторое задание, которое требуется выполнить, написав
программу на одном из языков программирования. Чтобы проверить корректность выполнения задания, текст программы
отправляют на проверку в тестирующую систему.

Под \textbf{тестирующей системой} в данной работе будем подразумевать сервер, на который учащиеся отправляют свой код, 
для проверки его корректного выполнения на заранее подготовленных тестах.

\textbf{Teст} для олимпиадной задачи по программированию~--- некоторые входные данные, удовлетворяющие условию задачи.
Как правило, представляет из себя текстовый файл. Для каждой задачи обычно существует свой набор тестов. В наборе может быть,
как один, так и несколько тестов. Тесты составляются до проведения соревнования или занятия и обычно неизвестны учащемуся.

\textbf{Решением} олимпиадной задачи называют программу, которая считывает входные данные, находит ответ и выводит его.
Также нередко в условии задачи присутствуют ограничения на время выполнения и количество используемой памяти, поэтому
корректное решение должно укладываться в эти ограничения.

\textbf{Вердикт} тестирующей системы~--- ответ тестирующей системы после проверки некоторого решения. 
Может быть положительным или одним из отрицательных. 
В случае получения положительного ответа, считается, что задача решена правильно, иначе, что в решении присутствует ошибка.
Как правило, вместе с вердиктом учащийся получает комментарий с номером теста, на котором решение работает некорректно.


\subsection{Теория графов}

\textbf{Граф}~--- абстрактный математический объект, который характеризует 
пара $G = (V, E)$, где $V$~--- множество вершин, а $E \subset \{(v, u): v, u \in V\}$~--- множество ребер. 

\textbf{Связный граф}~--- граф, в котором между любой парой вершин существует хотя бы один путь.

\textbf{Цикл}~--- последовательность вершин вида $v_1, v_2 \dots v_k$, где $v_i \in V$, 
$(v_i, v_{i+1}) \in E$ и $v_1 = v_k$.

\textbf{Ациклический граф}~--- граф, который не содержит в себе циклов.

\textbf{Дерево}~--- связный ациклический граф.

\textbf{Поиск в глубину}~--- один из наиболее популярных алгоритмов обхода графа, используемый для изучения строения. 

\subsection{Синтаксический анализ}

\textbf{Абстрактное синтаксическое дерево}(дерево разбора)~--- структура данных, представляющая из себя ориентированное дерево, 
в котором каждая вершина сопоставляется с оператором языка программирования, а листья с соответствующими операндами. 

\textbf{Лексический анализ}~--- процесс аналитического разбора 
входного текста на известные группы, с последующем получением на выходе 
идентифицированных последовательностей, называемых <<токенами>>. 
Лексический анализ используется в компиляторах и интерпретаторах исходного кода языков программирования, 
и в различных парсерах слов естественных языков.

\textbf{Лексическим анализатором}(жарг. лексер от англ. $lexer$) называется программа, выполняющая лексический анализ текста.

\textbf{Синтаксический анализ}(жарг. парсинг от англ. $parsing$)~--- процесс сопоставления последовательности токенов(слов)
формального языка с его формальной грамматикой. Результатом будет абстрактное синтаксическое дерево. Как правило, для получения
токенов проводится лексический анализ.

\textbf{Синтаксическим анализатором}(жарг. парсер от англ. $parser$) называется программа выполняющая синтаксический анализ.

\textbf{Генератор синтаксических анализаторов}~--- программа, которая получает на вход контекстно-свободную грамматику 
некоторого языка, а на выход выдает синтезированный код лексического и синтаксического анализаторов для данного языка.
Для большинства используемых в олимпиадном программировании языков программирования 
существуют стандартные уже реализованные грамматики.

\section{Ошибки}

\textbf{Ошибкой} будем называть причину, по которой решение получает отрицательный вердикт на одном из тестов.

\subsection{Классификация ошибок}

Множество ошибок можно интуитивно разделить на несколько категорий:
\begin{enumerate}
    \item \textbf{Идейные}. Данные ошибки совершаются по причине написания неправильной интерпритации условия,
        либо некорректного выбора алгоритма для решения. Простой пример~--- решение задачи динамического программирования 
        о рюкзаке, используя метод жадного программирования. 
    \item \textbf{Неэффективный выбор алгоритма}. У некоторых алгоритмов бывают разные версии и модификации,
        поэтому бывает, что, например вместо реализации алгоритма Дейкстры с кучей, учащийся пишет 
        реализацию алгоритма Дейкстры без кучи. В подобных случаях решение выдает правильный ответ, но может
        либо потреблять памяти больше, чем указанное в условии максимальное доступное количество памяти
        либо не успевает завершиться раньше указанного в условии максимального времени работы.
    \item \textbf{Неаккуратная реализация} также является частой причиной нарушения ограничений работы.
        Например, в решении используется неоптимальный способ считывания входных данных, или неподходящая
        структура данных. Сюда же можно отнести обращения к незаалоцированной памяти и подобные ошибки.
        Основная причина таких ошибок, заключается в том, что учащийся придумал правильную идею решения, 
        выбрал правильный алгоритм, но не смог его корректно реализовать.  
    \item \textbf{Нерассмотренные случаи} часто приводят к отрицательным вердиктам. Во многих задачах существуют крайние случаи,
        например, когда в массиве один элемент и в этом случае программа будет работать некорректно. Лечатся такие ошибки при помощи
        условного оператора и отдельного рассмотрения этих самых случаев.
    \item \textbf{<<Мелкие>>} ошибки можно сравнить с помарками при решении математической задачи, на подобии потери знака при переносе.
        Такие ошибки легко допустить, но сложно заметить при самопроверке. В области олимпиадного программирования к таким ошибкам
        можно причислить неправильные типы, ошибки в индексации, неправильные размеры массивов. Особым отличием таких ошибок
        является то, что для того, чтобы помочь учащемуся, достаточно просто указать область кода, где она совершена, либо
        ограничится фразой по типу: <<У Вас ошибка в ограничениях в массиве>>, либо <<Нужно использовать 
        шестидесятичетырехбитный тип данных, вместо тридцатидвухбитного>>.   
\end{enumerate}

\subsection{Выбор фокусировки исследования}
В представленой работе будем фокусироваться именно на <<мелких>>, на что есть несколько достаточно веских причин:
\begin{itemize}
    \item Ошибки, не являющееся <<мелкими>> непонятно как именно находить, и скорее всего задача по поиску таких
        является NP-полной.
    \item Также, даже если представить, что мы нашли не являющуюся <<мелкой>> ошибку автоматически, неясно как
        компьютер сможет объяснить участнику, что же у него не так. Естественно фраза <<Замените вот тот код, на вот этот>>
        с приложенным следом кодом сомнительна, как минимум потому, что с таким же успехом, можно сказать <<вот правильный
        код, используйте его>>.
    \item Как было сказано выше, в случае <<мелкой>> ошибки, компьютер будет несложно научить давать комментарии, помогающие
        найти и исправить ее. 
    \item В случае поиска <<мелкой>> ошибки лично преподавателем, нужно прочитать
        весь код, иногда несколько раз. Именно на поиски таких ошибок, обычно, тратится наибольшее количество
        преподавательского времени.
    \item <<Мелкие>> ошибки чаще всего встречаются в коде, который нужно посмотреть преподавателю на предмет ошибок, 
        так как учащемуся проще их допустить, а также гораздо сложнее найти их самостоятельно.
    \item Такие ошибки также обладают свойством повторяться, ведь чем меньше размер кода представляющего ошибку, 
        тем больше вероятность, что подобную повторит кто-либо другой.
\end{itemize}

\section{Постановка цели исследования}
Рассмотрим некоторый кружок, онлайн-курс или что-то подобное по олимпиадному программированию. 
В нем обучается некоторое количество учащихся, которых, как правило, многократно больше, чем преподавателей.

Процесс обучения включает в себя практику, которая представляет из себя решение олимпиадных задач, с последующей
отправкой решений на проверку в тестирующую систему. На каждую посылку решения, тестирующая система выдает некоторый вердикт.
В том случае, если вердикт положительный задача считается решенной правильно, и учащийся с чистой совестью переходит к решению
следующих задач, иначе же, учащийся будет пытаться самостоятельно найти ошибку.

Однако, как правило, большинство учащихся из-за лени, недостатка опыта, знаний или еще каких-либо причин не могут найти ошибку
самостоятельно и обращаются к преподавателю за помощью. Чтобы помочь в поиске ошибки, преподавателю необходимо прочитать код учащегося,
иногда не один раз, и потратить некоторое время. Когда подобных учащихся много, то и преподавательского времени тратиться 
непомерно много. Несложно предположить, что продуктивность преподавания можно повысить, если избавить преподавателя от 
подобных обязанностей путем автоматизации процесса.

Таким образом имеем базу предыдущих решений задачи с вердиктами, в том числе и с отрицательными, которые храняться в 
тестирующей системе. Хотим на основе этой информации, когда приходит новый запрос от учащегося на поиск ошибки, 
находить ее автоматически, если такая или подобная ей уже допускалась ранее другим участником. 

\section{Обзор области}
Работа, которая на первый взгляд должна помочь в достижении поставленной цели~--- это <<Automated software transplantation>>,
авторами которой являются Earl T.Barr, Mark Harman, Yue Jia, Alexandru Marginean и Justyna Petke.

В данной работе авторы рассматривают возможность <<пересадки>> кода из одной программы в другую, с целью передачи 
необходимой функциональности, по аналогии с трансплантацией огранов живого организма.

Для того, чтобы сделать это берется весь необходимый код, смотряться его зависимости от окружения и других частей программы, 
все это <<вырезается>> и ставится в код назначения в указанное место.

Несмотря на то, что метод зарекомендовал себя очень хорошо, работая в подовляющем большинстве тестовых случаев, применимо к поставленной
цели его использовать невозможно. Так как он попросту будет пересаживать код из правильного решения в неправильное и сообщать
что-то наподобии <<Я, конечно, не знаю, где у Вас ошибка, но если вы допишите в точности вот этот код, 
который раньше уже сдали в систему, то и Вы сдадите>>. Польза от данной информации, как уже было отмечено ранее крайне сомнительна,
да и в принципе ставит под вопрос необходимость использования таких сложных методов, лишь для того, чтобы показать учащемуся
правильный код, что, кстати, обычно, не делают, ведь теряется смысл обучения.

К сожалению, других работ, которые были бы хотя бы настолько близки к поставленной задаче попросту не существует, 
либо они не были найдены, несмотря на активные поиски автора. Что подводит к необходимости разработки своей системы синтеза
исправлений.


\section{Постановка задачи для исследования}
Основой исследования будут ранее сделанные изменения в коде решения, которые программа будет пробовать применить к текущему решению,
в котором требуется исправить ошибку.

Рассмотрим две посылки некоторого участника, который ранее получил положительный вердикт, по интересующей нас задаче.
При этом первая посылка из рассматриваемых получала отрицательный вердикт, а вторая либо положительный, либо отрицательный, но
на более высоком номере теста. Охарактеризуем множество кода этих посылок, как бла-бла-бла

\textbf{Исправлением} назовем пару $(C_1; C_2)$, где $C_1$~--- код 



\chapterconclusion

TBD